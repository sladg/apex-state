/**
 * WASM Bridge - Type-safe wrapper for apex-state WASM module
 *
 * This module provides a TypeScript interface to the Rust-based WASM
 * string interning functionality. It handles:
 * - Lazy loading of the WASM module
 * - Type-safe function signatures
 * - Error handling at the JS/WASM boundary
 *
 * @module wasm/bridge
 */

/**
 * PathID type - matches Rust's u32 PathID type
 * Represents an interned string identifier
 */
export type PathID = number

/**
 * WASM module interface - mirrors Rust exports from lib.rs
 *
 * All functions are automatically generated by wasm-bindgen and
 * exported from the compiled WASM module.
 */
export interface ApexStateWasm {
  /**
   * Intern a string path, returning its numeric PathID
   *
   * Same string always returns the same PathID (deduplication).
   *
   * @param path - The string path to intern
   * @returns PathID for the interned string
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name')
   * ```
   */
  intern: (path: string) => PathID

  /**
   * Resolve a PathID back to its original string
   *
   * Returns empty string if PathID is invalid.
   *
   * @param id - The PathID to resolve
   * @returns Original string path, or empty string if invalid
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name')
   * const path = wasm.resolve(id) // 'user.name'
   * ```
   */
  resolve: (id: PathID) => string

  /**
   * Batch intern multiple paths efficiently
   *
   * More efficient than calling intern() repeatedly as it
   * minimizes boundary crossings and table lookups.
   *
   * @param paths - Array of string paths to intern
   * @returns Array of PathIDs corresponding to each input path
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const ids = wasm.batch_intern(['user.name', 'user.email', 'user.age'])
   * ```
   */
  batch_intern: (paths: string[]) => PathID[]

  /**
   * Get the number of unique interned strings
   *
   * Useful for debugging and monitoring memory usage.
   *
   * @returns Count of unique interned strings
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * wasm.intern('user.name')
   * wasm.intern('user.email')
   * console.log(wasm.intern_count()) // 2
   * ```
   */
  intern_count: () => number

  /**
   * Clear the interning table
   *
   * Resets the global interning table to empty state.
   * Primarily useful for testing.
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * wasm.intern('user.name')
   * wasm.intern_clear()
   * console.log(wasm.intern_count()) // 0
   * ```
   */
  intern_clear: () => void

  /**
   * Example greeting function (from initial WASM template)
   *
   * @param name - Name to greet
   * @returns Greeting message
   */
  greet: (name: string) => string
}

/**
 * Singleton WASM instance
 * Initialized on first load, reused thereafter
 */
let wasmInstance: ApexStateWasm | null = null

/**
 * Promise for in-flight WASM loading
 * Prevents multiple simultaneous loads
 */
let loadingPromise: Promise<ApexStateWasm> | null = null

/**
 * Load the WASM module
 *
 * This function lazily loads the WASM module and caches it for
 * subsequent calls. Multiple calls while loading is in progress
 * will return the same promise.
 *
 * @returns Promise that resolves to the loaded WASM module
 * @throws Error if WASM module fails to load
 *
 * @example
 * ```typescript
 * const wasm = await loadWasm()
 * const id = wasm.intern('user.name')
 * ```
 */
export const loadWasm = async (): Promise<ApexStateWasm> => {
  // Return cached instance if already loaded
  if (wasmInstance) {
    return wasmInstance
  }

  // Return in-flight loading promise if currently loading
  if (loadingPromise) {
    return loadingPromise
  }

  // Start loading WASM module
  loadingPromise = (async () => {
    try {
      // Dynamic import of WASM module
      // Path will be resolved by bundler (Vite/webpack/etc)
      // Expected to be generated by wasm-pack in rust/pkg/
      const wasmModule = await import(
        /* @vite-ignore */
        '../../rust/pkg/apex_state_wasm.js'
      )

      // Cache the instance
      wasmInstance = wasmModule as ApexStateWasm

      return wasmInstance
    } catch (error) {
      // Reset loading state on failure
      loadingPromise = null

      throw new Error(
        `Failed to load WASM module: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
  })()

  return loadingPromise
}

/**
 * Check if WASM module is currently loaded
 *
 * @returns true if WASM module is loaded and ready to use
 *
 * @example
 * ```typescript
 * if (isWasmLoaded()) {
 *   // WASM is ready - can use synchronously
 * } else {
 *   await loadWasm()
 * }
 * ```
 */
export const isWasmLoaded = (): boolean => wasmInstance !== null

/**
 * Get the loaded WASM instance without triggering a load
 *
 * @returns The loaded WASM instance, or null if not yet loaded
 *
 * @example
 * ```typescript
 * const wasm = getWasmInstance()
 * if (wasm) {
 *   wasm.intern('user.name')
 * }
 * ```
 */
export const getWasmInstance = (): ApexStateWasm | null => wasmInstance

/**
 * Reset the WASM module (for testing)
 *
 * Clears the cached instance and loading promise, forcing a fresh
 * load on the next loadWasm() call.
 *
 * @internal
 */
export const resetWasm = (): void => {
  wasmInstance = null
  loadingPromise = null
}

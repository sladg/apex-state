/**
 * WASM Bridge - Type-safe wrapper for apex-state WASM module
 *
 * This module provides a TypeScript interface to the Rust-based WASM
 * string interning functionality. It handles:
 * - Lazy loading of the WASM module
 * - Type-safe function signatures
 * - Error handling at the JS/WASM boundary
 *
 * @module wasm/bridge
 */

/**
 * PathID type - matches Rust's u32 PathID type
 * Represents an interned string identifier
 */
export type PathID = number

/**
 * WASM module interface - mirrors Rust exports from lib.rs
 *
 * All functions are automatically generated by wasm-bindgen and
 * exported from the compiled WASM module.
 */
export interface ApexStateWasm {
  /**
   * Intern a string path, returning its numeric PathID
   *
   * Same string always returns the same PathID (deduplication).
   *
   * @param path - The string path to intern
   * @returns PathID for the interned string
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name')
   * ```
   */
  intern: (path: string) => PathID

  /**
   * Resolve a PathID back to its original string
   *
   * Returns empty string if PathID is invalid.
   *
   * @param id - The PathID to resolve
   * @returns Original string path, or empty string if invalid
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name')
   * const path = wasm.resolve(id) // 'user.name'
   * ```
   */
  resolve: (id: PathID) => string

  /**
   * Batch intern multiple paths efficiently
   *
   * More efficient than calling intern() repeatedly as it
   * minimizes boundary crossings and table lookups.
   *
   * @param paths - Array of string paths to intern
   * @returns Array of PathIDs corresponding to each input path
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const ids = wasm.batch_intern(['user.name', 'user.email', 'user.age'])
   * ```
   */
  batch_intern: (paths: string[]) => PathID[]

  /**
   * Get the number of unique interned strings
   *
   * Useful for debugging and monitoring memory usage.
   *
   * @returns Count of unique interned strings
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * wasm.intern('user.name')
   * wasm.intern('user.email')
   * console.log(wasm.intern_count()) // 2
   * ```
   */
  intern_count: () => number

  /**
   * Clear the interning table
   *
   * Resets the global interning table to empty state.
   * Primarily useful for testing.
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * wasm.intern('user.name')
   * wasm.intern_clear()
   * console.log(wasm.intern_count()) // 0
   * ```
   */
  intern_clear: () => void

  /**
   * Example greeting function (from initial WASM template)
   *
   * @param name - Name to greet
   * @returns Greeting message
   */
  greet: (name: string) => string
}

/**
 * Singleton WASM instance
 * Initialized on first load, reused thereafter
 */
let wasmInstance: ApexStateWasm | null = null

/**
 * Promise for in-flight WASM loading
 * Prevents multiple simultaneous loads
 */
let loadingPromise: Promise<ApexStateWasm> | null = null

/**
 * Load the WASM module
 *
 * This function lazily loads the WASM module and caches it for
 * subsequent calls. Multiple calls while loading is in progress
 * will return the same promise.
 *
 * @returns Promise that resolves to the loaded WASM module
 * @throws Error if WASM module fails to load
 *
 * @example
 * ```typescript
 * const wasm = await loadWasm()
 * const id = wasm.intern('user.name')
 * ```
 */
export const loadWasm = async (): Promise<ApexStateWasm> => {
  // Return cached instance if already loaded
  if (wasmInstance) {
    return wasmInstance
  }

  // Return in-flight loading promise if currently loading
  if (loadingPromise) {
    return loadingPromise
  }

  // Start loading WASM module
  loadingPromise = (async () => {
    try {
      // Dynamic import of WASM module
      // Path will be resolved by bundler (Vite/webpack/etc)
      // Expected to be generated by wasm-pack in rust/pkg/
      const wasmModule = await import(
        /* @vite-ignore */
        '../../rust/pkg/apex_state_wasm.js'
      )

      // Cache the instance
      wasmInstance = wasmModule as ApexStateWasm

      return wasmInstance
    } catch (error) {
      // Reset loading state on failure
      loadingPromise = null

      throw new Error(
        `Failed to load WASM module: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
  })()

  return loadingPromise
}

/**
 * Check if WASM module is currently loaded
 *
 * @returns true if WASM module is loaded and ready to use
 *
 * @example
 * ```typescript
 * if (isWasmLoaded()) {
 *   // WASM is ready - can use synchronously
 * } else {
 *   await loadWasm()
 * }
 * ```
 */
export const isWasmLoaded = (): boolean => wasmInstance !== null

/**
 * Get the loaded WASM instance without triggering a load
 *
 * @returns The loaded WASM instance, or null if not yet loaded
 *
 * @example
 * ```typescript
 * const wasm = getWasmInstance()
 * if (wasm) {
 *   wasm.intern('user.name')
 * }
 * ```
 */
export const getWasmInstance = (): ApexStateWasm | null => wasmInstance

/**
 * Reset the WASM module (for testing)
 *
 * Clears the cached instance and loading promise, forcing a fresh
 * load on the next loadWasm() call.
 *
 * @internal
 */
export const resetWasm = (): void => {
  wasmInstance = null
  loadingPromise = null
}

/**
 * Auto-Interning Wrapper Functions
 *
 * These convenience functions automatically load WASM and handle
 * string-to-PathID conversion, hiding the manual loadWasm() calls.
 * They demonstrate the auto-interning pattern used throughout the library.
 */

/**
 * Intern a path string with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then interns the provided path string to a PathID.
 *
 * @param path - The string path to intern
 * @returns Promise resolving to the PathID for the interned string
 *
 * @example
 * ```typescript
 * // No need to manually call loadWasm()
 * const id = await internPath('user.name')
 * ```
 */
export const internPath = async (path: string): Promise<PathID> => {
  const wasm = await loadWasm()
  return wasm.intern(path)
}

/**
 * Resolve a PathID with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then resolves the provided PathID back to its original string.
 *
 * @param id - The PathID to resolve
 * @returns Promise resolving to the original string path
 *
 * @example
 * ```typescript
 * const path = await resolvePath(42)
 * ```
 */
export const resolvePath = async (id: PathID): Promise<string> => {
  const wasm = await loadWasm()
  return wasm.resolve(id)
}

/**
 * Batch intern multiple paths with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then batch interns multiple path strings efficiently.
 *
 * @param paths - Array of string paths to intern
 * @returns Promise resolving to array of PathIDs
 *
 * @example
 * ```typescript
 * const ids = await batchInternPaths(['user.name', 'user.email', 'user.age'])
 * ```
 */
export const batchInternPaths = async (
  paths: string[],
): Promise<PathID[]> => {
  const wasm = await loadWasm()
  return wasm.batch_intern(paths)
}

/**
 * Batch resolve multiple PathIDs with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then resolves multiple PathIDs back to their original strings.
 *
 * @param ids - Array of PathIDs to resolve
 * @returns Promise resolving to array of string paths
 *
 * @example
 * ```typescript
 * const paths = await batchResolvePaths([0, 1, 2])
 * // ['user.name', 'user.email', 'user.age']
 * ```
 */
export const batchResolvePaths = async (
  ids: PathID[],
): Promise<string[]> => {
  const wasm = await loadWasm()
  return ids.map((id) => wasm.resolve(id))
}

/**
 * Get interned string count with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then returns the number of unique interned strings.
 *
 * @returns Promise resolving to the count of interned strings
 *
 * @example
 * ```typescript
 * const count = await getInternCount()
 * console.log(`${count} unique paths interned`)
 * ```
 */
export const getInternCount = async (): Promise<number> => {
  const wasm = await loadWasm()
  return wasm.intern_count()
}

/**
 * Clear the interning table with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then clears all interned strings. Primarily useful for testing.
 *
 * @returns Promise that resolves when clearing is complete
 *
 * @example
 * ```typescript
 * await clearInternTable()
 * ```
 */
export const clearInternTable = async (): Promise<void> => {
  const wasm = await loadWasm()
  wasm.intern_clear()
}

/**
 * Roundtrip a path through intern/resolve cycle (demonstration)
 *
 * This function demonstrates the complete auto-interning workflow:
 * 1. Auto-load WASM
 * 2. Intern string path to PathID
 * 3. Resolve PathID back to string
 *
 * Primarily useful for testing and demonstrating the interning pattern.
 *
 * @param path - The string path to roundtrip
 * @returns Promise resolving to the resolved path (should match input)
 *
 * @example
 * ```typescript
 * const result = await roundtripPath('user.name')
 * console.log(result) // 'user.name'
 * ```
 */
export const roundtripPath = async (path: string): Promise<string> => {
  const wasm = await loadWasm()
  const id = wasm.intern(path)
  return wasm.resolve(id)
}

/**
 * Auto-Resolve Wrapper Functions
 *
 * These wrappers demonstrate the auto-resolve pattern: they wrap
 * WASM operations that return PathIDs and automatically resolve
 * those IDs back to strings. This ensures JavaScript consumers
 * never need to work with PathIDs directly.
 */

/**
 * Intern a path and auto-resolve to verify storage (demonstration)
 *
 * This wrapper demonstrates the auto-resolve pattern:
 * 1. Intern the path string to get a PathID
 * 2. Automatically resolve the PathID back to string
 * 3. Return the resolved string to JavaScript
 *
 * This ensures JavaScript never sees the PathID - it only works
 * with strings on both input and output.
 *
 * @param path - The string path to intern
 * @returns Promise resolving to the resolved string (verifies storage)
 *
 * @example
 * ```typescript
 * const result = await internAndResolve('user.name')
 * console.log(result) // 'user.name' - verified from WASM storage
 * ```
 */
export const internAndResolve = async (path: string): Promise<string> => {
  const wasm = await loadWasm()
  const id = wasm.intern(path)
  return wasm.resolve(id)
}

/**
 * Batch intern paths and auto-resolve to verify storage (demonstration)
 *
 * This wrapper demonstrates the auto-resolve pattern for batch operations:
 * 1. Batch intern multiple path strings to get PathIDs
 * 2. Automatically resolve all PathIDs back to strings
 * 3. Return the resolved strings to JavaScript
 *
 * This ensures JavaScript never sees PathIDs - it only works
 * with string arrays on both input and output.
 *
 * @param paths - Array of string paths to intern
 * @returns Promise resolving to array of resolved strings (verifies storage)
 *
 * @example
 * ```typescript
 * const results = await batchInternAndResolve(['user.name', 'user.email'])
 * console.log(results) // ['user.name', 'user.email'] - verified from WASM
 * ```
 */
export const batchInternAndResolve = async (
  paths: string[],
): Promise<string[]> => {
  const wasm = await loadWasm()
  const ids = wasm.batch_intern(paths)
  return ids.map((id) => wasm.resolve(id))
}

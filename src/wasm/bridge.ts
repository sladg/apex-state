/**
 * WASM Bridge - Type-safe wrapper for apex-state WASM module
 *
 * This module provides a TypeScript interface to the Rust-based WASM
 * string interning functionality. It handles:
 * - Lazy loading of the WASM module
 * - Type-safe function signatures
 * - Error handling at the JS/WASM boundary
 *
 * ## String Interning Overview
 *
 * String interning is a memory optimization technique where identical strings
 * are stored only once and referenced by numeric IDs. This provides:
 *
 * - **Deduplication**: "user.name" stored once, referenced many times
 * - **Memory efficiency**: Numeric PathIDs (u32) use less memory than strings
 * - **Fast comparison**: Compare PathIDs (number equality) vs string comparison
 * - **Cross-boundary optimization**: Passing numbers between JS/WASM is faster
 *
 * ## String ↔ ID Conversion Pattern
 *
 * The core interning pattern is:
 * 1. **intern(path)**: Convert string → PathID (deduplicates automatically)
 * 2. **resolve(id)**: Convert PathID → original string (lookup)
 * 3. Same string always gets same PathID (identity guarantee)
 *
 * @module wasm/bridge
 */

/**
 * PathID type - matches Rust's u32 PathID type
 * Represents an interned string identifier
 */
export type PathID = number

/**
 * WASM module interface - mirrors Rust exports from lib.rs
 *
 * All functions are automatically generated by wasm-bindgen and
 * exported from the compiled WASM module.
 */
export interface ApexStateWasm {
  /**
   * Intern a string path, returning its numeric PathID
   *
   * **Interning Behavior:**
   * - First call with a string: stores it and returns a new PathID
   * - Subsequent calls with same string: returns the existing PathID (deduplication)
   * - PathIDs are stable for the lifetime of the interning table
   * - Example: intern('user.name') always returns the same ID (e.g., 42)
   *
   * **Use Case:**
   * Convert strings to compact numeric IDs for efficient storage and comparison.
   * Critical for performance when tracking many paths in dependency graphs.
   *
   * @param path - The string path to intern
   * @returns PathID for the interned string (stable identity)
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id1 = wasm.intern('user.name') // e.g., 42 (new)
   * const id2 = wasm.intern('user.name') // 42 (reused - deduplication)
   * const id3 = wasm.intern('user.email') // 43 (new)
   * ```
   */
  intern: (path: string) => PathID

  /**
   * Resolve a PathID back to its original string
   *
   * **Interning Behavior:**
   * - Reverse lookup: PathID → original string
   * - Returns the exact string that was interned with this ID
   * - Returns empty string if PathID is invalid (never interned)
   * - Fast O(1) lookup in the interning table
   *
   * **Use Case:**
   * Convert compact PathIDs back to human-readable strings for logging,
   * debugging, or when crossing the WASM→JS boundary.
   *
   * @param id - The PathID to resolve
   * @returns Original string path, or empty string if invalid
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name') // PathID: 42
   * const path = wasm.resolve(id) // 'user.name' (exact match)
   * const invalid = wasm.resolve(9999) // '' (not found)
   * ```
   */
  resolve: (id: PathID) => string

  /**
   * Batch intern multiple paths efficiently
   *
   * **Interning Behavior:**
   * - Interns multiple strings in a single WASM call (reduces overhead)
   * - Each path follows same deduplication rules as intern()
   * - Returns PathIDs in same order as input paths
   * - Duplicate paths in input array will get same PathID
   *
   * **Performance:**
   * More efficient than calling intern() repeatedly because:
   * - Single JS→WASM boundary crossing (vs N crossings)
   * - Batch table operations in Rust (better cache locality)
   * - Reduced serialization/deserialization overhead
   *
   * @param paths - Array of string paths to intern
   * @returns Array of PathIDs corresponding to each input path
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const ids = wasm.batch_intern(['user.name', 'user.email', 'user.name'])
   * // [42, 43, 42] - note: 'user.name' gets same ID both times
   * ```
   */
  batch_intern: (paths: string[]) => PathID[]

  /**
   * Get the number of unique interned strings
   *
   * **Interning Behavior:**
   * - Returns count of unique strings in the interning table
   * - Duplicate interned strings only count once (shows deduplication)
   * - Useful for monitoring memory usage and verifying deduplication
   *
   * **Use Case:**
   * Debug and verify interning behavior - if count is lower than
   * total intern() calls, deduplication is working.
   *
   * @returns Count of unique interned strings
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * wasm.intern('user.name')
   * wasm.intern('user.name') // duplicate
   * wasm.intern('user.email')
   * console.log(wasm.intern_count()) // 2 (not 3 - deduplication worked)
   * ```
   */
  intern_count: () => number

  /**
   * Clear the interning table
   *
   * **Interning Behavior:**
   * - Removes all interned strings from the table
   * - Resets PathID counter to 0
   * - After clearing, previously valid PathIDs become invalid
   * - Subsequent intern() calls will reuse PathIDs (e.g., 0, 1, 2...)
   *
   * **Warning:**
   * Invalidates all existing PathIDs! Only use in tests or when
   * you're sure no code is holding PathID references.
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const id = wasm.intern('user.name') // PathID: 0
   * wasm.intern_clear()
   * console.log(wasm.intern_count()) // 0
   * wasm.resolve(id) // '' (PathID 0 no longer valid)
   * const newId = wasm.intern('user.name') // PathID: 0 (reused)
   * ```
   */
  intern_clear: () => void

  /**
   * Example greeting function (from initial WASM template)
   *
   * @param name - Name to greet
   * @returns Greeting message
   */
  greet: (name: string) => string

  /**
   * Evaluate a BoolLogic expression against a state object
   *
   * **BoolLogic Evaluation:**
   * - Accepts JavaScript BoolLogic expressions in the format `{ "OPERATOR": [args] }`
   * - No transformation needed - JS objects deserialize directly via serde
   * - Supports all 11 operators: IS_EQUAL, EXISTS, IS_EMPTY, AND, OR, NOT, GT, LT, GTE, LTE, IN
   * - Recursive evaluation for AND/OR/NOT operators with nested expressions
   * - Returns boolean result of the evaluation
   *
   * **Use Case:**
   * High-performance reactive condition checking in WASM. Used for evaluating
   * complex boolean logic expressions against state objects without serialization overhead.
   *
   * @param logic - BoolLogic expression object (e.g., `{ "IS_EQUAL": ["user.role", "admin"] }`)
   * @param state - State object to evaluate against (arbitrary JSON structure)
   * @returns Boolean result of the evaluation
   * @throws Error if logic or state cannot be deserialized
   *
   * @example
   * ```typescript
   * const wasm = await loadWasm()
   * const logic = { "IS_EQUAL": ["user.role", "admin"] }
   * const state = { user: { role: "admin" } }
   * const result = wasm.evaluate_bool_logic(logic, state) // true
   *
   * // Complex nested expression
   * const complexLogic = {
   *   "AND": [
   *     { "GT": ["age", 18] },
   *     { "EXISTS": "email" }
   *   ]
   * }
   * const complexState = { age: 25, email: "test@example.com" }
   * const complexResult = wasm.evaluate_bool_logic(complexLogic, complexState) // true
   * ```
   */
  evaluate_bool_logic: (logic: unknown, state: unknown) => boolean
}

/**
 * Singleton WASM instance
 * Initialized on first load, reused thereafter
 */
let wasmInstance: ApexStateWasm | null = null

/**
 * Promise for in-flight WASM loading
 * Prevents multiple simultaneous loads
 */
let loadingPromise: Promise<ApexStateWasm> | null = null

/**
 * Load the WASM module
 *
 * This function lazily loads the WASM module and caches it for
 * subsequent calls. Multiple calls while loading is in progress
 * will return the same promise.
 *
 * @returns Promise that resolves to the loaded WASM module
 * @throws Error if WASM module fails to load
 *
 * @example
 * ```typescript
 * const wasm = await loadWasm()
 * const id = wasm.intern('user.name')
 * ```
 */
export const loadWasm = async (): Promise<ApexStateWasm> => {
  // Return cached instance if already loaded
  if (wasmInstance) {
    return wasmInstance
  }

  // Return in-flight loading promise if currently loading
  if (loadingPromise) {
    return loadingPromise
  }

  // Start loading WASM module
  loadingPromise = (async () => {
    try {
      // Dynamic import of WASM module
      // Path will be resolved by bundler (Vite/webpack/etc)
      // Expected to be generated by wasm-pack in rust/pkg/
      const wasmModule = await import(
        /* @vite-ignore */
        '../../rust/pkg/apex_state_wasm.js'
      )

      // Initialize the WASM module by calling the default export
      // This sets up the internal wasm instance required for all functions
      if (typeof wasmModule.default === 'function') {
        await wasmModule.default()
      }

      // Cache the instance
      wasmInstance = wasmModule as ApexStateWasm

      return wasmInstance
    } catch (error) {
      // Reset loading state on failure
      loadingPromise = null

      throw new Error(
        `Failed to load WASM module: ${error instanceof Error ? error.message : String(error)}`,
      )
    }
  })()

  return loadingPromise
}

/**
 * Check if WASM module is currently loaded
 *
 * @returns true if WASM module is loaded and ready to use
 *
 * @example
 * ```typescript
 * if (isWasmLoaded()) {
 *   // WASM is ready - can use synchronously
 * } else {
 *   await loadWasm()
 * }
 * ```
 */
export const isWasmLoaded = (): boolean => wasmInstance !== null

/**
 * Get the loaded WASM instance without triggering a load
 *
 * @returns The loaded WASM instance, or null if not yet loaded
 *
 * @example
 * ```typescript
 * const wasm = getWasmInstance()
 * if (wasm) {
 *   wasm.intern('user.name')
 * }
 * ```
 */
export const getWasmInstance = (): ApexStateWasm | null => wasmInstance

/**
 * Reset the WASM module (for testing)
 *
 * Clears the cached instance and loading promise, forcing a fresh
 * load on the next loadWasm() call.
 *
 * @internal
 */
export const resetWasm = (): void => {
  wasmInstance = null
  loadingPromise = null
}

/**
 * Auto-Interning Wrapper Functions
 *
 * These convenience functions automatically load WASM and handle
 * string-to-PathID conversion, hiding the manual loadWasm() calls.
 * They demonstrate the auto-interning pattern used throughout the library.
 *
 * **Interning Pattern:**
 * - Auto-load: WASM loads on first call, cached for subsequent calls
 * - Auto-intern: Strings automatically convert to PathIDs internally
 * - Transparent: Consumers don't need to know about WASM loading or PathIDs
 *
 * **Use Case:**
 * Use these wrappers when you want the simplest API - just pass strings,
 * get results, without managing WASM lifecycle or PathID conversion.
 */

/**
 * Intern a path string with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then interns the provided path string to a PathID.
 *
 * **Interning Behavior:**
 * - Auto-loads WASM on first call (cached thereafter)
 * - Interns string → PathID with deduplication
 * - Returns stable PathID (same string always gets same ID)
 *
 * @param path - The string path to intern
 * @returns Promise resolving to the PathID for the interned string
 *
 * @example
 * ```typescript
 * // No need to manually call loadWasm()
 * const id1 = await internPath('user.name') // WASM loads + intern
 * const id2 = await internPath('user.name') // Cached + deduplicated
 * console.log(id1 === id2) // true (same PathID)
 * ```
 */
export const internPath = async (path: string): Promise<PathID> => {
  const wasm = await loadWasm()
  return wasm.intern(path)
}

/**
 * Resolve a PathID with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then resolves the provided PathID back to its original string.
 *
 * **Interning Behavior:**
 * - Auto-loads WASM if needed
 * - Resolves PathID → original string (reverse lookup)
 * - Returns empty string if PathID is invalid
 *
 * @param id - The PathID to resolve
 * @returns Promise resolving to the original string path
 *
 * @example
 * ```typescript
 * const id = await internPath('user.name')
 * const path = await resolvePath(id) // 'user.name'
 * ```
 */
export const resolvePath = async (id: PathID): Promise<string> => {
  const wasm = await loadWasm()
  return wasm.resolve(id)
}

/**
 * Batch intern multiple paths with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then batch interns multiple path strings efficiently.
 *
 * @param paths - Array of string paths to intern
 * @returns Promise resolving to array of PathIDs
 *
 * @example
 * ```typescript
 * const ids = await batchInternPaths(['user.name', 'user.email', 'user.age'])
 * ```
 */
export const batchInternPaths = async (paths: string[]): Promise<PathID[]> => {
  const wasm = await loadWasm()
  return wasm.batch_intern(paths)
}

/**
 * Batch resolve multiple PathIDs with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then resolves multiple PathIDs back to their original strings.
 *
 * @param ids - Array of PathIDs to resolve
 * @returns Promise resolving to array of string paths
 *
 * @example
 * ```typescript
 * const paths = await batchResolvePaths([0, 1, 2])
 * // ['user.name', 'user.email', 'user.age']
 * ```
 */
export const batchResolvePaths = async (ids: PathID[]): Promise<string[]> => {
  const wasm = await loadWasm()
  return ids.map((id) => wasm.resolve(id))
}

/**
 * Get interned string count with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then returns the number of unique interned strings.
 *
 * @returns Promise resolving to the count of interned strings
 *
 * @example
 * ```typescript
 * const count = await getInternCount()
 * console.log(`${count} unique paths interned`)
 * ```
 */
export const getInternCount = async (): Promise<number> => {
  const wasm = await loadWasm()
  return wasm.intern_count()
}

/**
 * Clear the interning table with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then clears all interned strings. Primarily useful for testing.
 *
 * @returns Promise that resolves when clearing is complete
 *
 * @example
 * ```typescript
 * await clearInternTable()
 * ```
 */
export const clearInternTable = async (): Promise<void> => {
  const wasm = await loadWasm()
  wasm.intern_clear()
}

/**
 * Roundtrip a path through intern/resolve cycle (demonstration)
 *
 * This function demonstrates the complete auto-interning workflow:
 * 1. Auto-load WASM
 * 2. Intern string path to PathID
 * 3. Resolve PathID back to string
 *
 * **Interning Behavior:**
 * - Verifies string → PathID → string is an identity operation
 * - Tests both interning (deduplication) and resolution (lookup)
 * - Useful for validating interning table integrity
 *
 * Primarily useful for testing and demonstrating the interning pattern.
 *
 * @param path - The string path to roundtrip
 * @returns Promise resolving to the resolved path (should match input)
 *
 * @example
 * ```typescript
 * const result = await roundtripPath('user.name')
 * console.log(result === 'user.name') // true (identity preserved)
 * ```
 */
export const roundtripPath = async (path: string): Promise<string> => {
  const wasm = await loadWasm()
  const id = wasm.intern(path)
  return wasm.resolve(id)
}

/**
 * Auto-Resolve Wrapper Functions
 *
 * These wrappers demonstrate the auto-resolve pattern: they wrap
 * WASM operations that return PathIDs and automatically resolve
 * those IDs back to strings. This ensures JavaScript consumers
 * never need to work with PathIDs directly.
 *
 * **Interning Pattern:**
 * - String → intern → PathID (internal, hidden from JS)
 * - PathID → resolve → String (automatic, transparent)
 * - JS only sees strings on both input and output
 *
 * **Use Case:**
 * Ideal for testing and verification - ensures data roundtrips correctly
 * through the interning system (string → ID → string should be identity).
 */

/**
 * Intern a path and auto-resolve to verify storage (demonstration)
 *
 * This wrapper demonstrates the auto-resolve pattern:
 * 1. Intern the path string to get a PathID
 * 2. Automatically resolve the PathID back to string
 * 3. Return the resolved string to JavaScript
 *
 * **Interning Behavior:**
 * - PathID is created but never exposed to JavaScript
 * - String → PathID → String conversion is transparent
 * - Verifies interning table correctly stores and retrieves strings
 * - JS consumers only see strings (PathIDs are internal implementation)
 *
 * This ensures JavaScript never sees the PathID - it only works
 * with strings on both input and output.
 *
 * @param path - The string path to intern
 * @returns Promise resolving to the resolved string (verifies storage)
 *
 * @example
 * ```typescript
 * const result = await internAndResolve('user.name')
 * console.log(result) // 'user.name' - verified from WASM storage
 * // PathID was used internally but never exposed
 * ```
 */
export const internAndResolve = async (path: string): Promise<string> => {
  const wasm = await loadWasm()
  const id = wasm.intern(path)
  return wasm.resolve(id)
}

/**
 * Batch intern paths and auto-resolve to verify storage (demonstration)
 *
 * This wrapper demonstrates the auto-resolve pattern for batch operations:
 * 1. Batch intern multiple path strings to get PathIDs
 * 2. Automatically resolve all PathIDs back to strings
 * 3. Return the resolved strings to JavaScript
 *
 * **Interning Behavior:**
 * - Batch interns all strings efficiently (single WASM call)
 * - PathIDs are created but never exposed to JavaScript
 * - All PathIDs automatically resolved back to strings
 * - Verifies batch interning correctly handles deduplication
 * - Duplicate input strings will resolve to same value (verifies dedup)
 *
 * This ensures JavaScript never sees PathIDs - it only works
 * with string arrays on both input and output.
 *
 * @param paths - Array of string paths to intern
 * @returns Promise resolving to array of resolved strings (verifies storage)
 *
 * @example
 * ```typescript
 * const results = await batchInternAndResolve(['user.name', 'user.email', 'user.name'])
 * console.log(results) // ['user.name', 'user.email', 'user.name']
 * // All PathIDs were used internally but never exposed
 * // Note: duplicate 'user.name' got same PathID internally (deduplication)
 * ```
 */
export const batchInternAndResolve = async (
  paths: string[],
): Promise<string[]> => {
  const wasm = await loadWasm()
  const ids = wasm.batch_intern(paths)
  return ids.map((id) => wasm.resolve(id))
}

/**
 * BoolLogic Evaluation Wrapper Functions
 *
 * These convenience functions automatically load WASM and handle
 * BoolLogic evaluation, hiding the manual loadWasm() calls.
 *
 * **BoolLogic Pattern:**
 * - Auto-load: WASM loads on first call, cached for subsequent calls
 * - Direct format: JS objects in `{ "OPERATOR": [args] }` format pass through directly
 * - Type-safe: TypeScript types ensure BoolLogic expressions are well-formed
 * - Error handling: Deserialization errors are thrown as descriptive messages
 *
 * **Use Case:**
 * Use these wrappers for the simplest API - just pass BoolLogic expressions and state,
 * get boolean results, without managing WASM lifecycle or serialization.
 */

/**
 * Evaluate a BoolLogic expression with auto-loading
 *
 * Convenience wrapper that automatically loads WASM if needed,
 * then evaluates the provided BoolLogic expression against the state.
 *
 * **BoolLogic Evaluation:**
 * - Auto-loads WASM on first call (cached thereafter)
 * - Accepts BoolLogic expressions in the format `{ "OPERATOR": [args] }`
 * - Evaluates against provided state object
 * - Returns boolean result of the evaluation
 * - Throws error if logic or state cannot be deserialized
 *
 * @param logic - BoolLogic expression object
 * @param state - State object to evaluate against
 * @returns Promise resolving to the boolean evaluation result
 *
 * @example
 * ```typescript
 * // Simple equality check
 * const result1 = await evaluateBoolLogic(
 *   { "IS_EQUAL": ["user.role", "admin"] },
 *   { user: { role: "admin" } }
 * ) // true
 *
 * // Complex nested expression
 * const result2 = await evaluateBoolLogic(
 *   {
 *     "AND": [
 *       { "GT": ["age", 18] },
 *       { "EXISTS": "email" }
 *     ]
 *   },
 *   { age: 25, email: "test@example.com" }
 * ) // true
 * ```
 */
export const evaluateBoolLogic = async (
  logic: unknown,
  state: unknown,
): Promise<boolean> => {
  const wasm = await loadWasm()
  return wasm.evaluate_bool_logic(logic, state)
}

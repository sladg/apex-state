//! Generator binary: writes TypeScript type definitions from Rust structs.
//!
//! Run via: `npm run wasm:generate-types`
//! Only compiles with `--features ts-export` (never included in WASM binary).

use ts_rs::TS;

use apex_state_wasm::aggregation::Aggregation;
use apex_state_wasm::bool_logic::BoolLogicNode;
use apex_state_wasm::change::{Change, PipelineTrace, StageTrace};
use apex_state_wasm::computation::{Computation, ComputationOp};
use apex_state_wasm::pipeline::{
    BoolLogicRegistration, ConcernsRegistration, ConcernsResult, FinalizeResult, GraphSnapshot,
    ListenerRegistration, PrepareResult, SideEffectsRegistration, SideEffectsResult,
    ValidatorDispatch, ValidatorRegistration, ValueLogicRegistration,
};
use apex_state_wasm::router::FullExecutionPlan;
use apex_state_wasm::value_logic::{ValueLogicElse, ValueLogicNode};

fn main() {
    let out_file = std::path::Path::new("src/wasm/generated/types.ts");

    // Ensure parent directory exists
    if let Some(parent) = out_file.parent() {
        std::fs::create_dir_all(parent).expect("create generated dir");
    }

    let mut output = String::from(
        "// Auto-generated by `npm run wasm:generate-types` — DO NOT EDIT\n/* eslint-disable */\n\n",
    );

    // Collect all type declarations into a single file
    collect_all(&mut output);

    // Post-process: add `export` keyword, fix JsonValue → unknown, bigint → number
    let output = output
        .replace("type ", "export type ")
        .replace("JsonValue", "unknown")
        .replace("bigint", "number");

    std::fs::write(out_file, &output).expect("write types.ts");
    println!("TypeScript types exported to {}", out_file.display());
}

/// Append inline type declaration for a single type.
macro_rules! append_type {
    ($out:expr, $ty:ty) => {
        $out.push_str(&<$ty>::decl());
        $out.push_str("\n\n");
    };
}

fn collect_all(out: &mut String) {
    // change.rs — public types (internal helpers inlined via #[ts(inline)])
    append_type!(out, Change);
    append_type!(out, StageTrace); // kept: self-recursive via followup
    append_type!(out, PipelineTrace);

    // pipeline.rs — output types
    append_type!(out, ValidatorDispatch);
    append_type!(out, PrepareResult);
    append_type!(out, GraphSnapshot);
    append_type!(out, FinalizeResult);
    append_type!(out, SideEffectsResult);
    append_type!(out, ConcernsResult);

    // pipeline.rs — registration input types
    append_type!(out, ListenerRegistration);
    append_type!(out, SideEffectsRegistration);
    append_type!(out, BoolLogicRegistration);
    append_type!(out, ValueLogicRegistration);
    append_type!(out, ValidatorRegistration);
    append_type!(out, ConcernsRegistration);

    // router.rs — kept: FullExecutionPlan (internal helpers inlined)
    append_type!(out, FullExecutionPlan);

    // bool_logic.rs — kept: self-recursive
    append_type!(out, BoolLogicNode);

    // value_logic.rs — kept: mutually recursive
    append_type!(out, ValueLogicNode);
    append_type!(out, ValueLogicElse);

    // aggregation.rs — public types (AggregationSource inlined)
    append_type!(out, Aggregation);

    // computation.rs — public types (ComputationSource inlined)
    append_type!(out, ComputationOp);
    append_type!(out, Computation);
}
